{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shield Documentation Installation Guide Concepts You Need To Know Quick Start Guide Authentication Authorization Auth Actions Events Testing Customization Guides Protecting an API with Access Tokens Mobile Authentication with Access Tokens","title":"Home"},{"location":"#shield-documentation","text":"Installation Guide Concepts You Need To Know Quick Start Guide Authentication Authorization Auth Actions Events Testing Customization","title":"Shield Documentation"},{"location":"#guides","text":"Protecting an API with Access Tokens Mobile Authentication with Access Tokens","title":"Guides"},{"location":"auth_actions/","text":"Authentication Actions Authentication Actions Configuring Actions Defining New Actions Authentication Actions are a way to group actions that can happen after login or registration. Shield ships with two actions you can use, and makes it simple for you to define your own. Email-based Account Activation (EmailActivate) confirms a new user's email address by sending them an email with a link they must follow in order to have their account activated. Email-based Two Factor Authentication (Email2FA) will send a 6-digit code to the user's email address that they must confirm before they can continue. Configuring Actions Actions are setup in the Auth config file, with the $actions variable. public $actions = [ 'register' => null, 'login' => null, ]; To define an action to happen you will specify the class name as the value for the appropriate task: public $actions = [ 'register' => 'CodeIgniter\\Shield\\Authentication\\Actions\\EmailActivator', 'login' => 'CodeIgniter\\Shield\\Authentication\\Actions\\Email2FA', ]; You must register actions in the order of the actions to be performed. Once configured, everything should work out of the box. The routes are added with the basic auth()->routes($routes) call, but can be manually added if you choose not to use this helper method. use CodeIgniter\\Shield\\Controllers\\ActionController; $routes->get('auth/a/show', 'ActionController::show'); $routes->post('auth/a/handle', 'ActionController::handle'); $routes->post('auth/a/verify', 'ActionController::verify'); Views for all of these pages are defined in the Auth config file, with the $views array. public $views = [ 'action_email_2fa' => '\\CodeIgniter\\Shield\\Views\\email_2fa_show', 'action_email_2fa_verify' => '\\CodeIgniter\\Shield\\Views\\email_2fa_verify', 'action_email_2fa_email' => '\\CodeIgniter\\Shield\\Views\\Email\\email_2fa_email', 'action_email_activate_show' => '\\CodeIgniter\\Shield\\Views\\email_activate_show', 'action_email_activate_email' => '\\CodeIgniter\\Shield\\Views\\Email\\email_activate_email', ]; Defining New Actions While the provided email-based activation and 2FA will work for many sites, others will have different needs, like using SMS to verify or something completely different. Actions have only one requirement: they must implement CodeIgniter\\Shield\\Authentication\\Actions\\ActionInterface . The interface defines three methods for ActionController : show() should display the initial page the user lands on immediately after the authentication task, like login. It will typically display instructions to the user and provide an action to take, like clicking a button to have an email or SMS message sent. You might verify email address or phone numbers here. handle() is the next page the user would land on and can be used to handle the action the show() told the user would be happening. For example, in the Email2FA class, this method generates the code, sends the email to the user, and then displays the form the user should enter the 6 digit code into. verify() is the final step in the action's journey. It verifies the information the user provided and provides feedback. In the Email2FA class, it verifies the code against what is saved in the database and either sends them back to the previous form to try again or redirects the user to the page that a login task would have redirected them to anyway. All methods should return either a Response or a view string (e.g. using the view() function).","title":"Auth Actions"},{"location":"auth_actions/#authentication-actions","text":"Authentication Actions Configuring Actions Defining New Actions Authentication Actions are a way to group actions that can happen after login or registration. Shield ships with two actions you can use, and makes it simple for you to define your own. Email-based Account Activation (EmailActivate) confirms a new user's email address by sending them an email with a link they must follow in order to have their account activated. Email-based Two Factor Authentication (Email2FA) will send a 6-digit code to the user's email address that they must confirm before they can continue.","title":"Authentication Actions"},{"location":"auth_actions/#configuring-actions","text":"Actions are setup in the Auth config file, with the $actions variable. public $actions = [ 'register' => null, 'login' => null, ]; To define an action to happen you will specify the class name as the value for the appropriate task: public $actions = [ 'register' => 'CodeIgniter\\Shield\\Authentication\\Actions\\EmailActivator', 'login' => 'CodeIgniter\\Shield\\Authentication\\Actions\\Email2FA', ]; You must register actions in the order of the actions to be performed. Once configured, everything should work out of the box. The routes are added with the basic auth()->routes($routes) call, but can be manually added if you choose not to use this helper method. use CodeIgniter\\Shield\\Controllers\\ActionController; $routes->get('auth/a/show', 'ActionController::show'); $routes->post('auth/a/handle', 'ActionController::handle'); $routes->post('auth/a/verify', 'ActionController::verify'); Views for all of these pages are defined in the Auth config file, with the $views array. public $views = [ 'action_email_2fa' => '\\CodeIgniter\\Shield\\Views\\email_2fa_show', 'action_email_2fa_verify' => '\\CodeIgniter\\Shield\\Views\\email_2fa_verify', 'action_email_2fa_email' => '\\CodeIgniter\\Shield\\Views\\Email\\email_2fa_email', 'action_email_activate_show' => '\\CodeIgniter\\Shield\\Views\\email_activate_show', 'action_email_activate_email' => '\\CodeIgniter\\Shield\\Views\\Email\\email_activate_email', ];","title":"Configuring Actions"},{"location":"auth_actions/#defining-new-actions","text":"While the provided email-based activation and 2FA will work for many sites, others will have different needs, like using SMS to verify or something completely different. Actions have only one requirement: they must implement CodeIgniter\\Shield\\Authentication\\Actions\\ActionInterface . The interface defines three methods for ActionController : show() should display the initial page the user lands on immediately after the authentication task, like login. It will typically display instructions to the user and provide an action to take, like clicking a button to have an email or SMS message sent. You might verify email address or phone numbers here. handle() is the next page the user would land on and can be used to handle the action the show() told the user would be happening. For example, in the Email2FA class, this method generates the code, sends the email to the user, and then displays the form the user should enter the 6 digit code into. verify() is the final step in the action's journey. It verifies the information the user provided and provides feedback. In the Email2FA class, it verifies the code against what is saved in the database and either sends them back to the previous form to try again or redirects the user to the page that a login task would have redirected them to anyway. All methods should return either a Response or a view string (e.g. using the view() function).","title":"Defining New Actions"},{"location":"authentication/","text":"Authentication Authentication Available Authenticators Auth Helper Authenticator Responses isOK() reason() extraInfo() Session Authenticator attempt() check() loggedIn() logout() forget() Access Token Authenticator Access Token/API Authentication Generating Access Tokens Revoking Access Tokens Retrieving Access Tokens Access Token Lifetime Access Token Scopes Authentication is the process of determining that a visitor actually belongs to your website, and identifying them. Shield provides a flexible and secure authentication system for your web apps and APIs. Available Authenticators Shield ships with 2 authenticators that will serve several typical situations within web app development: the Session authenticator, which uses username/email/password to authenticate against and stores it in the session, and the Access Tokens authenticator which uses private access tokens passed in the headers. The available authenticators are defined in Config\\Auth : public $authenticators = [ // alias => classname 'session' => Session::class, 'tokens' => AccessTokens::class, ]; The default authenticator is also defined in the configuration file, and uses the alias given above: public $defaultAuthenticator = 'session'; Auth Helper The auth functionality is designed to be used with the auth_helper that comes with Shield. This helper method provides the auth() command which returns a convenient interface to the most frequently used functionality within the auth libraries. This must be loaded before it can be used. // get the current user auth()->user(); // get the current user's id auth()->id(); // or user_id(); Note The auth_helper is autoloaded by Composer. If you want to override the functions, you need to define them in app/Common.php . Authenticator Responses Many of the authenticator methods will return a CodeIgniter\\Shield\\Result class. This provides a consistent way of checking the results and can have additional information return along with it. The class has the following methods: isOK() Returns a boolean value stating whether the check was successful or not. reason() Returns a message that can be displayed to the user when the check fails. extraInfo() Can return a custom bit of information. These will be detailed in the method descriptions below. Session Authenticator The Session authenticator stores the user's authentication within the user's session, and on a secure cookie on their device. This is the standard password-based login used in most web sites. It supports a secure remember me feature, and more. This can also be used to handle authentication for single page applications (SPAs). attempt() When a user attempts to login with their email and password, you would call the attempt() method on the auth class, passing in their credentials. $credentials = [ 'email' => $this->request->getPost('email'), 'password' => $this->request->getPost('password') ]; $loginAttempt = auth()->attempt($credentials); if (! $loginAttempt->isOK()) { return redirect()->back()->with('error', $loginAttempt->reason()); } Upon a successful attempt() , the user is logged in. The Response object returned will provide the user that was logged in as extraInfo() . $result = auth()->attempt($credentials); if ($result->isOK()) { $user = $result->extraInfo(); } If the attempt fails a failedLogin event is triggered with the credentials array as the only parameter. Whether or not they pass, a login attempt is recorded in the auth_logins table. If allowRemembering is true in the Auth config file, you can tell the Session authenticator to set a secure remember-me cookie. $loginAttempt = auth()->remember()->attempt($credentials); check() If you would like to check a user's credentials without logging them in, you can use the check() method. $credentials = [ 'email' => $this->request->getPost('email'), 'password' => $this->request->getPost('password') ]; $validCreds = auth()->check($credentials); if (! $validCreds->isOK()) { return redirect()->back()->with('error', $validCreds->reason()); } The Result instance returned contains the valid user as extraInfo() . loggedIn() You can determine if a user is currently logged in with the aptly titled method, loggedIn() . if (auth()->loggedIn()) { // Do something. } logout() You can call the logout() method to log the user out of the current session. This will destroy and regenerate the current session, purge any remember-me tokens current for this user, and trigger a logout event. auth()->logout(); forget() The forget method will purge all remember-me tokens for the current user, making it so they will not be remembered on the next visit to the site. Access Token Authenticator The Access Token authenticator supports the use of revoke-able API tokens without using OAuth. These are commonly used to provide third-party developers access to your API. These tokens typically have a very long expiration time, often years. These are also suitable for use with mobile applications. In this case, the user would register/sign-in with their email/password. The application would create a new access token for them, with a recognizable name, like John's iPhone 12, and return it to the mobile application, where it is stored and used in all future requests. Access Token/API Authentication Using access tokens requires that you either use/extend CodeIgniter\\Shield\\Models\\UserModel or use the CodeIgniter\\Shield\\Authentication\\Traits\\HasAccessTokens on your own user model. This trait provides all of the custom methods needed to implement access tokens in your application. The necessary database table, auth_identities , is created in Shield's only migration class, which must be run before first using any of the features of Shield. Generating Access Tokens Access tokens are created through the generateAccessToken() method on the user. This takes a name to give to the token as the first argument. The name is used to display it to the user so they can differentiate between multiple tokens. $token = $user->generateAccessToken('Work Laptop'); This creates the token using a cryptographically secure random string. The token is hashed (sha256) before saving it to the database. The method returns an instance of CodeIgniters\\Shield\\Authentication\\Entities\\AccessToken . The only time a plain text version of the token is available is in the AccessToken returned immediately after creation. The plain text version should be displayed to the user immediately so they can copy it for their use. If a user loses it, they cannot see the raw version anymore, but they can generate a new token to use. $token = $user->generateAccessToken('Work Laptop'); // Only available immediately after creation. echo $token->raw_token; Revoking Access Tokens Access tokens can be revoked through the revokeAccessToken() method. This takes the plain-text access token as the only argument. Revoking simply deletes the record from the database. $user->revokeAccessToken($token); Typically, the plain text token is retrieved from the request's headers as part of the authentication process. If you need to revoke the token for another user as an admin, and don't have access to the token, you would need to get the user's access tokens and delete them manually. You can revoke all access tokens with the revokeAllAccessTokens() method. $user->revokeAllAccessTokens(); Retrieving Access Tokens The following methods are available to help you retrieve a user's access tokens: // Retrieve a single token by plain text token $token = $user->getAccessToken($rawToken); // Retrieve a single token by it's database ID $token = $user->getAccessTokenById($id); // Retrieve all access tokens as an array of AccessToken instances. $tokens = $user->accessTokens(); Access Token Lifetime Tokens will expire after a specified amount of time has passed since they have been used. By default, this is set to 1 year. You can change this value by setting the accessTokenLifetime value in the Auth config file. This is in seconds so that you can use the time constants that CodeIgniter provides. public $unusedTokenLifetime = YEAR; Access Token Scopes Each token can be given one or more scopes they can be used within. These can be thought of as permissions the token grants to the user. Scopes are provided when the token is generated and cannot be modified afterword. $token = $user->gererateAccessToken('Work Laptop', ['posts.manage', 'forums.manage']); By default a user is granted a wildcard scope which provides access to all scopes. This is the same as: $token = $user->gererateAccessToken('Work Laptop', ['*']); During authentication, the token the user used is stored on the user. Once authenticated, you can use the tokenCan() and tokenCant() methods on the user to determine if they have access to the specified scope. if ($user->tokenCan('posts.manage')) { // do something.... } if ($user->tokenCant('forums.manage')) { // do something.... }","title":"Authentication"},{"location":"authentication/#authentication","text":"Authentication Available Authenticators Auth Helper Authenticator Responses isOK() reason() extraInfo() Session Authenticator attempt() check() loggedIn() logout() forget() Access Token Authenticator Access Token/API Authentication Generating Access Tokens Revoking Access Tokens Retrieving Access Tokens Access Token Lifetime Access Token Scopes Authentication is the process of determining that a visitor actually belongs to your website, and identifying them. Shield provides a flexible and secure authentication system for your web apps and APIs.","title":"Authentication"},{"location":"authentication/#available-authenticators","text":"Shield ships with 2 authenticators that will serve several typical situations within web app development: the Session authenticator, which uses username/email/password to authenticate against and stores it in the session, and the Access Tokens authenticator which uses private access tokens passed in the headers. The available authenticators are defined in Config\\Auth : public $authenticators = [ // alias => classname 'session' => Session::class, 'tokens' => AccessTokens::class, ]; The default authenticator is also defined in the configuration file, and uses the alias given above: public $defaultAuthenticator = 'session';","title":"Available Authenticators"},{"location":"authentication/#auth-helper","text":"The auth functionality is designed to be used with the auth_helper that comes with Shield. This helper method provides the auth() command which returns a convenient interface to the most frequently used functionality within the auth libraries. This must be loaded before it can be used. // get the current user auth()->user(); // get the current user's id auth()->id(); // or user_id(); Note The auth_helper is autoloaded by Composer. If you want to override the functions, you need to define them in app/Common.php .","title":"Auth Helper"},{"location":"authentication/#authenticator-responses","text":"Many of the authenticator methods will return a CodeIgniter\\Shield\\Result class. This provides a consistent way of checking the results and can have additional information return along with it. The class has the following methods:","title":"Authenticator Responses"},{"location":"authentication/#isok","text":"Returns a boolean value stating whether the check was successful or not.","title":"isOK()"},{"location":"authentication/#reason","text":"Returns a message that can be displayed to the user when the check fails.","title":"reason()"},{"location":"authentication/#extrainfo","text":"Can return a custom bit of information. These will be detailed in the method descriptions below.","title":"extraInfo()"},{"location":"authentication/#session-authenticator","text":"The Session authenticator stores the user's authentication within the user's session, and on a secure cookie on their device. This is the standard password-based login used in most web sites. It supports a secure remember me feature, and more. This can also be used to handle authentication for single page applications (SPAs).","title":"Session Authenticator"},{"location":"authentication/#attempt","text":"When a user attempts to login with their email and password, you would call the attempt() method on the auth class, passing in their credentials. $credentials = [ 'email' => $this->request->getPost('email'), 'password' => $this->request->getPost('password') ]; $loginAttempt = auth()->attempt($credentials); if (! $loginAttempt->isOK()) { return redirect()->back()->with('error', $loginAttempt->reason()); } Upon a successful attempt() , the user is logged in. The Response object returned will provide the user that was logged in as extraInfo() . $result = auth()->attempt($credentials); if ($result->isOK()) { $user = $result->extraInfo(); } If the attempt fails a failedLogin event is triggered with the credentials array as the only parameter. Whether or not they pass, a login attempt is recorded in the auth_logins table. If allowRemembering is true in the Auth config file, you can tell the Session authenticator to set a secure remember-me cookie. $loginAttempt = auth()->remember()->attempt($credentials);","title":"attempt()"},{"location":"authentication/#check","text":"If you would like to check a user's credentials without logging them in, you can use the check() method. $credentials = [ 'email' => $this->request->getPost('email'), 'password' => $this->request->getPost('password') ]; $validCreds = auth()->check($credentials); if (! $validCreds->isOK()) { return redirect()->back()->with('error', $validCreds->reason()); } The Result instance returned contains the valid user as extraInfo() .","title":"check()"},{"location":"authentication/#loggedin","text":"You can determine if a user is currently logged in with the aptly titled method, loggedIn() . if (auth()->loggedIn()) { // Do something. }","title":"loggedIn()"},{"location":"authentication/#logout","text":"You can call the logout() method to log the user out of the current session. This will destroy and regenerate the current session, purge any remember-me tokens current for this user, and trigger a logout event. auth()->logout();","title":"logout()"},{"location":"authentication/#forget","text":"The forget method will purge all remember-me tokens for the current user, making it so they will not be remembered on the next visit to the site.","title":"forget()"},{"location":"authentication/#access-token-authenticator","text":"The Access Token authenticator supports the use of revoke-able API tokens without using OAuth. These are commonly used to provide third-party developers access to your API. These tokens typically have a very long expiration time, often years. These are also suitable for use with mobile applications. In this case, the user would register/sign-in with their email/password. The application would create a new access token for them, with a recognizable name, like John's iPhone 12, and return it to the mobile application, where it is stored and used in all future requests.","title":"Access Token Authenticator"},{"location":"authentication/#access-tokenapi-authentication","text":"Using access tokens requires that you either use/extend CodeIgniter\\Shield\\Models\\UserModel or use the CodeIgniter\\Shield\\Authentication\\Traits\\HasAccessTokens on your own user model. This trait provides all of the custom methods needed to implement access tokens in your application. The necessary database table, auth_identities , is created in Shield's only migration class, which must be run before first using any of the features of Shield.","title":"Access Token/API Authentication"},{"location":"authentication/#generating-access-tokens","text":"Access tokens are created through the generateAccessToken() method on the user. This takes a name to give to the token as the first argument. The name is used to display it to the user so they can differentiate between multiple tokens. $token = $user->generateAccessToken('Work Laptop'); This creates the token using a cryptographically secure random string. The token is hashed (sha256) before saving it to the database. The method returns an instance of CodeIgniters\\Shield\\Authentication\\Entities\\AccessToken . The only time a plain text version of the token is available is in the AccessToken returned immediately after creation. The plain text version should be displayed to the user immediately so they can copy it for their use. If a user loses it, they cannot see the raw version anymore, but they can generate a new token to use. $token = $user->generateAccessToken('Work Laptop'); // Only available immediately after creation. echo $token->raw_token;","title":"Generating Access Tokens"},{"location":"authentication/#revoking-access-tokens","text":"Access tokens can be revoked through the revokeAccessToken() method. This takes the plain-text access token as the only argument. Revoking simply deletes the record from the database. $user->revokeAccessToken($token); Typically, the plain text token is retrieved from the request's headers as part of the authentication process. If you need to revoke the token for another user as an admin, and don't have access to the token, you would need to get the user's access tokens and delete them manually. You can revoke all access tokens with the revokeAllAccessTokens() method. $user->revokeAllAccessTokens();","title":"Revoking Access Tokens"},{"location":"authentication/#retrieving-access-tokens","text":"The following methods are available to help you retrieve a user's access tokens: // Retrieve a single token by plain text token $token = $user->getAccessToken($rawToken); // Retrieve a single token by it's database ID $token = $user->getAccessTokenById($id); // Retrieve all access tokens as an array of AccessToken instances. $tokens = $user->accessTokens();","title":"Retrieving Access Tokens"},{"location":"authentication/#access-token-lifetime","text":"Tokens will expire after a specified amount of time has passed since they have been used. By default, this is set to 1 year. You can change this value by setting the accessTokenLifetime value in the Auth config file. This is in seconds so that you can use the time constants that CodeIgniter provides. public $unusedTokenLifetime = YEAR;","title":"Access Token Lifetime"},{"location":"authentication/#access-token-scopes","text":"Each token can be given one or more scopes they can be used within. These can be thought of as permissions the token grants to the user. Scopes are provided when the token is generated and cannot be modified afterword. $token = $user->gererateAccessToken('Work Laptop', ['posts.manage', 'forums.manage']); By default a user is granted a wildcard scope which provides access to all scopes. This is the same as: $token = $user->gererateAccessToken('Work Laptop', ['*']); During authentication, the token the user used is stored on the user. Once authenticated, you can use the tokenCan() and tokenCant() methods on the user to determine if they have access to the specified scope. if ($user->tokenCan('posts.manage')) { // do something.... } if ($user->tokenCant('forums.manage')) { // do something.... }","title":"Access Token Scopes"},{"location":"authorization/","text":"Authorization Authorization Defining Available Groups Default User Group Defining Available Permissions Assigning Permissions to Groups Authorizing Users can() inGroup() hasPermission() Managing User Permissions addPermission() removePermission() syncPermissions() getPermissions() Managing User Groups addGroup() removeGroup() syncGroups() getGroups() Authorization happens once a user has been identified through authentication. It is the process of determining what actions a user is allowed to do within your site. Shield provides a flexible role-based access control (RBAC) that allows users to belong to multiple groups at once. Groups can be thought of as traditional roles (admin, moderator, user, etc), but can also group people together around features, like Beta feature access, or used to provide discrete groups of users within a forum, etc. Defining Available Groups Groups are defined within the Shield\\Config\\AuthGroups config class. public $groups = [ 'superadmin' => [ 'title' => 'Super Admin', 'description' => 'Optional description of the group.', ], ]; The key of the $groups array is the common term of the group. This is what you would call when referencing the group elsewhere, like checking if $user->inGroup('superadmin') . By default, the following groups are available: superadmin , admin , developer , user , and beta . Default User Group When a user is first registered on the site, they are assigned to a default user group. This group is defined in app/config/AuthGroups::defaultGroup , and must match the name of one of the defined groups. public $defaultGroup = 'users'; Defining Available Permissions All permissions must be added to the AuthGroups config file, also. A permission is simply a string consisting of a scope and action, like users.create . The scope would be users and the action would be create . Each permission can have a description for display within UIs if needed. public $permissions = [ 'admin.access' => 'Can access the sites admin area', 'admin.settings' => 'Can access the main site settings', 'users.manage-admins' => 'Can manage other admins', 'users.create' => 'Can create new non-admin users', 'users.edit' => 'Can edit existing non-admin users', 'users.delete' => 'Can delete existing non-admin users', 'beta.access' => 'Can access beta-level features' ]; Assigning Permissions to Groups In order to grant any permissions to a group, they must have the permission assigned to the group, within the AuthGroups config file, under the $matrix property. The matrix is an associative array with the group name as the key, and an array of permissions that should be applied to that group. public $matrix = [ 'admin' => ['admin.access', 'users.create', 'users.edit', 'users.delete', 'beta.access'], ]; You can use a wildcard within a scope to allow all actions within that scope, by using a * in place of the action. public $matrix = [ 'superadmin' => ['admin.*', 'users.*', 'beta.*'], ]; Authorizing Users The Authorizable trait on the User entity provides the following methods to authorize your users. can() Allows you to check if a user is permitted to do a specific action. The only argument is the permission string. Returns boolean true / false . Will check the user's direct permissions first, and then check against all of the user's groups permissions to determine if they are allowed. if ($user->can('users.create')) { // } inGroup() Checks if the user is in one of the groups passed in. Returns boolean true / false . if (! $user->inGroup('superadmin', 'admin')) { // } hasPermission() Checks to see if the user has the permission set directly on themselves. This disregards any groups they are part of. if (! $user->hasPermission('users.create')) { // } Managing User Permissions Permissions can be granted on a user level as well as on a group level. Any user-level permissions granted will override the group, so it's possible that a user can perform an action that their groups cannot. addPermission() Adds one or more permissions to the user. If a permission doesn't exist, a CodeIgniter\\Shield\\Authorization\\AuthorizationException is thrown. $user->addPermission('users.create', 'users.edit'); removePermission() Removes one or more permissions from a user. If a permission doesn't exist, a CodeIgniter\\Shield\\Authorization\\AuthorizationException is thrown. $user->removePermission('users.delete'); syncPermissions() Updates the user's permissions to only include the permissions in the given list. Any existing permissions on that user not in this list will be removed. $user->syncPermissions('admin.access', 'beta.access'); getPermissions() Returns all permissions this user has assigned directly to them. $user->getPermissions(); Managing User Groups addGroup() Adds one or more groups to a user. If a group doesn't exist, a CodeIgniter\\Shield\\Authorization\\AuthorizationException is thrown. $user->addGroup('admin', 'beta'); removeGroup() Removes one or more groups from a user. If a group doesn't exist, a CodeIgniter\\Shield\\Authorization\\AuthorizationException is thrown. $user->removeGroup('admin', 'beta'); syncGroups() Updates the user's groups to only include the groups in the given list. Any existing groups on that user not in this list will be removed. $user->syncGroups('admin', 'beta'); getGroups() Returns all groups this user is a part of. $user->getGroups();","title":"Authorization"},{"location":"authorization/#authorization","text":"Authorization Defining Available Groups Default User Group Defining Available Permissions Assigning Permissions to Groups Authorizing Users can() inGroup() hasPermission() Managing User Permissions addPermission() removePermission() syncPermissions() getPermissions() Managing User Groups addGroup() removeGroup() syncGroups() getGroups() Authorization happens once a user has been identified through authentication. It is the process of determining what actions a user is allowed to do within your site. Shield provides a flexible role-based access control (RBAC) that allows users to belong to multiple groups at once. Groups can be thought of as traditional roles (admin, moderator, user, etc), but can also group people together around features, like Beta feature access, or used to provide discrete groups of users within a forum, etc.","title":"Authorization"},{"location":"authorization/#defining-available-groups","text":"Groups are defined within the Shield\\Config\\AuthGroups config class. public $groups = [ 'superadmin' => [ 'title' => 'Super Admin', 'description' => 'Optional description of the group.', ], ]; The key of the $groups array is the common term of the group. This is what you would call when referencing the group elsewhere, like checking if $user->inGroup('superadmin') . By default, the following groups are available: superadmin , admin , developer , user , and beta .","title":"Defining Available Groups"},{"location":"authorization/#default-user-group","text":"When a user is first registered on the site, they are assigned to a default user group. This group is defined in app/config/AuthGroups::defaultGroup , and must match the name of one of the defined groups. public $defaultGroup = 'users';","title":"Default User Group"},{"location":"authorization/#defining-available-permissions","text":"All permissions must be added to the AuthGroups config file, also. A permission is simply a string consisting of a scope and action, like users.create . The scope would be users and the action would be create . Each permission can have a description for display within UIs if needed. public $permissions = [ 'admin.access' => 'Can access the sites admin area', 'admin.settings' => 'Can access the main site settings', 'users.manage-admins' => 'Can manage other admins', 'users.create' => 'Can create new non-admin users', 'users.edit' => 'Can edit existing non-admin users', 'users.delete' => 'Can delete existing non-admin users', 'beta.access' => 'Can access beta-level features' ];","title":"Defining Available Permissions"},{"location":"authorization/#assigning-permissions-to-groups","text":"In order to grant any permissions to a group, they must have the permission assigned to the group, within the AuthGroups config file, under the $matrix property. The matrix is an associative array with the group name as the key, and an array of permissions that should be applied to that group. public $matrix = [ 'admin' => ['admin.access', 'users.create', 'users.edit', 'users.delete', 'beta.access'], ]; You can use a wildcard within a scope to allow all actions within that scope, by using a * in place of the action. public $matrix = [ 'superadmin' => ['admin.*', 'users.*', 'beta.*'], ];","title":"Assigning Permissions to Groups"},{"location":"authorization/#authorizing-users","text":"The Authorizable trait on the User entity provides the following methods to authorize your users.","title":"Authorizing Users"},{"location":"authorization/#can","text":"Allows you to check if a user is permitted to do a specific action. The only argument is the permission string. Returns boolean true / false . Will check the user's direct permissions first, and then check against all of the user's groups permissions to determine if they are allowed. if ($user->can('users.create')) { // }","title":"can()"},{"location":"authorization/#ingroup","text":"Checks if the user is in one of the groups passed in. Returns boolean true / false . if (! $user->inGroup('superadmin', 'admin')) { // }","title":"inGroup()"},{"location":"authorization/#haspermission","text":"Checks to see if the user has the permission set directly on themselves. This disregards any groups they are part of. if (! $user->hasPermission('users.create')) { // }","title":"hasPermission()"},{"location":"authorization/#managing-user-permissions","text":"Permissions can be granted on a user level as well as on a group level. Any user-level permissions granted will override the group, so it's possible that a user can perform an action that their groups cannot.","title":"Managing User Permissions"},{"location":"authorization/#addpermission","text":"Adds one or more permissions to the user. If a permission doesn't exist, a CodeIgniter\\Shield\\Authorization\\AuthorizationException is thrown. $user->addPermission('users.create', 'users.edit');","title":"addPermission()"},{"location":"authorization/#removepermission","text":"Removes one or more permissions from a user. If a permission doesn't exist, a CodeIgniter\\Shield\\Authorization\\AuthorizationException is thrown. $user->removePermission('users.delete');","title":"removePermission()"},{"location":"authorization/#syncpermissions","text":"Updates the user's permissions to only include the permissions in the given list. Any existing permissions on that user not in this list will be removed. $user->syncPermissions('admin.access', 'beta.access');","title":"syncPermissions()"},{"location":"authorization/#getpermissions","text":"Returns all permissions this user has assigned directly to them. $user->getPermissions();","title":"getPermissions()"},{"location":"authorization/#managing-user-groups","text":"","title":"Managing User Groups"},{"location":"authorization/#addgroup","text":"Adds one or more groups to a user. If a group doesn't exist, a CodeIgniter\\Shield\\Authorization\\AuthorizationException is thrown. $user->addGroup('admin', 'beta');","title":"addGroup()"},{"location":"authorization/#removegroup","text":"Removes one or more groups from a user. If a group doesn't exist, a CodeIgniter\\Shield\\Authorization\\AuthorizationException is thrown. $user->removeGroup('admin', 'beta');","title":"removeGroup()"},{"location":"authorization/#syncgroups","text":"Updates the user's groups to only include the groups in the given list. Any existing groups on that user not in this list will be removed. $user->syncGroups('admin', 'beta');","title":"syncGroups()"},{"location":"authorization/#getgroups","text":"Returns all groups this user is a part of. $user->getGroups();","title":"getGroups()"},{"location":"concepts/","text":"Shield Concepts This document covers some of the base concepts used throughout the library. Shield Concepts Repository State Settings User Providers User Identities Password Validators Repository State Shield is designed so that the initial setup of your application can all happen in code with nothing required to be saved in the database. This means you do not have to create large seeder files that need to run within each environment. Instead, it can be placed under version control, though the Settings library allows those settings to be easily stored in the database if you create an interface for the user to update those settings. Settings In place of the CodeIgniter config() helper, Shield uses the official Settings library. This provides a way to save any Config class values to the database if you want to modify them, but falls back on the standard Config class if nothing is found in the database. User Providers You can use your own models to handle user persistence. Shield calls this the \"User Provider\" class. A default model is provided for you at CodeIgniter\\Shield\\Models\\UserModel . You can change this in the Config\\Auth->userProvider setting. The only requirement is that your new class MUST extend the provided UserModel . public $userProvider = 'CodeIgniter\\Shield\\Models\\UserModel'; User Identities User accounts are stored separately from the information needed to identify that user. These identifying pieces of data are called User Identities. By default, the library has two types of identities: one for standard email/password information, and one for access tokens. Keeping these identities loosely coupled from the user account itself facilitates integrations with third-party sign-in systems, JWT systems, and more - all on a single user. While this has the potential to make the system more complex, the email and password fields are automatically looked up for you when attempting to access them from the User entity. Caution should be used to craft queries that will pull in the email field when you need to display it to the user, as you could easily run into some n+1 slow queries otherwise. When you save($user) a User instance in the UserModel , the email/password identity will automatically be updated. If no email/password identity exists, you must pass both the email and the password to the User instance prior to calling save() . Password Validators When registering a user account, the user's password must be validated to ensure it matches the security requirements of your application. Shield uses a pipeline of Validators to handle the validation. This allows you turn on or off any validation systems that are appropriate for your application. The following Validators are available: CompositionValidator validates the makeup of the password itself. This used to include things like ensuring it contained a symbol, a number, etc. According to the current NIST recommendations this only enforces a minimum length on the password. You can define the minimum length in Config\\Auth->public $minimumPasswordLength; This is enabled by default. The default minimum value is 8 . NothingPersonalValidator will compare the password against any fields that have been specified in Config\\Auth->personalFields , like first or last names, etc. Additionally, it compares it against a few simple variations of the username. If the given password too closely matches any of the personal information, it will be rejected. The similarity value is defined in Config\\Auth->maxSimilarity . The default value is 50, but see the docblock in the config file for more details. This is enabled by default. DictionaryValidator will compare the password against a provided file with about 600,000 frequently used passwords that have been seen in various data dumps over the years. If the chosen password matches any found in the file, it will be rejected. This is enabled by default. PwnedValidator is like the DictionaryValidator . Instead of comparing to a local file, it uses a third-party site, Have I Been Pwned to check against a list of over 630 million leaked passwords from many data dumps across the web. The search is done securely, and provides more information than the simple dictionary version. However, this does require an API call to a third-party which not every application will find acceptable. You should use either this validator or the DictionaryValidator , not both. This is disabled by default. You can choose which validators are used in Config\\Auth->passwordValidators : public $passwordValidators = [ 'CodeIgniter\\Shield\\Authentication\\Passwords\\CompositionValidator', 'CodeIgniter\\Shield\\Authentication\\Passwords\\NothingPersonalValidator', 'CodeIgniter\\Shield\\Authentication\\Passwords\\DictionaryValidator', //'CodeIgniter\\Shield\\Authentication\\Passwords\\PwnedValidator', ]; You use strong_password rule for password validation explained above. Note The strong_password rule only supports use cases to check the user's own password. It fetches the authenticated user's data for NothingPersonalValidator if the visitor is authenticated. If you want to have use cases that set and check another user's password, you can't use strong_password . You need to use service('passwords') directly to check the password. But remember, it is not good practice to set passwords for other users. This is because the password should be known only by that user.","title":"Concepts"},{"location":"concepts/#shield-concepts","text":"This document covers some of the base concepts used throughout the library. Shield Concepts Repository State Settings User Providers User Identities Password Validators","title":"Shield Concepts"},{"location":"concepts/#repository-state","text":"Shield is designed so that the initial setup of your application can all happen in code with nothing required to be saved in the database. This means you do not have to create large seeder files that need to run within each environment. Instead, it can be placed under version control, though the Settings library allows those settings to be easily stored in the database if you create an interface for the user to update those settings.","title":"Repository State"},{"location":"concepts/#settings","text":"In place of the CodeIgniter config() helper, Shield uses the official Settings library. This provides a way to save any Config class values to the database if you want to modify them, but falls back on the standard Config class if nothing is found in the database.","title":"Settings"},{"location":"concepts/#user-providers","text":"You can use your own models to handle user persistence. Shield calls this the \"User Provider\" class. A default model is provided for you at CodeIgniter\\Shield\\Models\\UserModel . You can change this in the Config\\Auth->userProvider setting. The only requirement is that your new class MUST extend the provided UserModel . public $userProvider = 'CodeIgniter\\Shield\\Models\\UserModel';","title":"User Providers"},{"location":"concepts/#user-identities","text":"User accounts are stored separately from the information needed to identify that user. These identifying pieces of data are called User Identities. By default, the library has two types of identities: one for standard email/password information, and one for access tokens. Keeping these identities loosely coupled from the user account itself facilitates integrations with third-party sign-in systems, JWT systems, and more - all on a single user. While this has the potential to make the system more complex, the email and password fields are automatically looked up for you when attempting to access them from the User entity. Caution should be used to craft queries that will pull in the email field when you need to display it to the user, as you could easily run into some n+1 slow queries otherwise. When you save($user) a User instance in the UserModel , the email/password identity will automatically be updated. If no email/password identity exists, you must pass both the email and the password to the User instance prior to calling save() .","title":"User Identities"},{"location":"concepts/#password-validators","text":"When registering a user account, the user's password must be validated to ensure it matches the security requirements of your application. Shield uses a pipeline of Validators to handle the validation. This allows you turn on or off any validation systems that are appropriate for your application. The following Validators are available: CompositionValidator validates the makeup of the password itself. This used to include things like ensuring it contained a symbol, a number, etc. According to the current NIST recommendations this only enforces a minimum length on the password. You can define the minimum length in Config\\Auth->public $minimumPasswordLength; This is enabled by default. The default minimum value is 8 . NothingPersonalValidator will compare the password against any fields that have been specified in Config\\Auth->personalFields , like first or last names, etc. Additionally, it compares it against a few simple variations of the username. If the given password too closely matches any of the personal information, it will be rejected. The similarity value is defined in Config\\Auth->maxSimilarity . The default value is 50, but see the docblock in the config file for more details. This is enabled by default. DictionaryValidator will compare the password against a provided file with about 600,000 frequently used passwords that have been seen in various data dumps over the years. If the chosen password matches any found in the file, it will be rejected. This is enabled by default. PwnedValidator is like the DictionaryValidator . Instead of comparing to a local file, it uses a third-party site, Have I Been Pwned to check against a list of over 630 million leaked passwords from many data dumps across the web. The search is done securely, and provides more information than the simple dictionary version. However, this does require an API call to a third-party which not every application will find acceptable. You should use either this validator or the DictionaryValidator , not both. This is disabled by default. You can choose which validators are used in Config\\Auth->passwordValidators : public $passwordValidators = [ 'CodeIgniter\\Shield\\Authentication\\Passwords\\CompositionValidator', 'CodeIgniter\\Shield\\Authentication\\Passwords\\NothingPersonalValidator', 'CodeIgniter\\Shield\\Authentication\\Passwords\\DictionaryValidator', //'CodeIgniter\\Shield\\Authentication\\Passwords\\PwnedValidator', ]; You use strong_password rule for password validation explained above. Note The strong_password rule only supports use cases to check the user's own password. It fetches the authenticated user's data for NothingPersonalValidator if the visitor is authenticated. If you want to have use cases that set and check another user's password, you can't use strong_password . You need to use service('passwords') directly to check the password. But remember, it is not good practice to set passwords for other users. This is because the password should be known only by that user.","title":"Password Validators"},{"location":"customization/","text":"Customizing Shield Customizing Shield Route Configuration Custom Redirect URLs Extending the Controllers Custom Validation Rules Registration Login Route Configuration If you need to customize how any of the auth features are handled, you will likely need to update the routes to point to the correct controllers. You can still use the service('auth')->routes() helper, but you will need to pass the except option with a list of routes to customize: service('auth')->routes($routes, ['except' => ['login', 'register']]); Then add the routes to your customized controllers: $routes->get('login', '\\App\\Controllers\\Auth\\LoginController::loginView'); $routes->get('register', '\\App\\Controllers\\Auth\\RegisterController::registerView'); Custom Redirect URLs By default, a successful login or register attempt will all redirect to / , while a logout action will redirect to /login . You can change the default URLs used within the Auth config file: public array $redirects = [ 'register' => '/', 'login' => '/', 'logout' => 'login', ]; Oftentimes, you will want to have different redirects for different user groups. A simple example might be that you want admins redirected to /admin while all other groups redirect to / . The Auth config file also includes methods that you can add additional logic to in order to achieve this: public function loginRedirect(): string { if (auth()->user()->can('admin.access')) { return '/admin'; } $url = setting('Auth.redirects')['login']; return $this->getUrl($url); } Extending the Controllers Shield has the following controllers that can be extended to handle various parts of the authentication process: ActionController handles the after-login and after-registration actions, like Two Factor Authentication and Email Verification. LoginController handles the login process. RegisterController handles the registration process. Overriding this class allows you to customize the User Provider, the User Entity, and the validation rules. MagicLinkController handles the \"lost password\" process that allows a user to login with a link sent to their email. This allows you to override the message that is displayed to a user to describe what is happening, if you'd like to provide more information than simply swapping out the view used. It is not recommended to copy the entire controller into app/Controllers and change its namespace. Instead, you should create a new controller that extends the existing controller and then only override the methods needed. This allows the other methods to stay up to date with any security updates that might happen in the controllers. <?php namespace App\\Controllers; use CodeIgniter\\Shield\\Controllers\\LoginController as ShieldLogin; class LoginController extends ShieldLogin { public function logoutAction() { // new functionality } } Custom Validation Rules Registration Shield has the following rules for registration: [ 'username' => [ 'label' => 'Auth.username', 'rules' => 'required|max_length[30]|min_length[3]|regex_match[/\\A[a-zA-Z0-9\\.]+\\z/]|is_unique[users.username]', ], 'email' => [ 'label' => 'Auth.email', 'rules' => 'required|max_length[254]|valid_email|is_unique[auth_identities.secret]', ], 'password' => [ 'label' => 'Auth.password', 'rules' => 'required|strong_password', ], 'password_confirm' => [ 'label' => 'Auth.passwordConfirm', 'rules' => 'required|matches[password]', ], ]; If you need a different set of rules for registration, you can specify them in your Validation configuration ( app/Config/Validation.php ) like: //-------------------------------------------------------------------- // Rules For Registration //-------------------------------------------------------------------- public $registration = [ 'username' => [ 'label' => 'Auth.username', 'rules' => 'required|max_length[30]|min_length[3]|regex_match[/\\A[a-zA-Z0-9\\.]+\\z/]|is_unique[users.username]', ], 'email' => [ 'label' => 'Auth.email', 'rules' => 'required|max_length[254]|valid_email|is_unique[auth_identities.secret]', ], 'password' => [ 'label' => 'Auth.password', 'rules' => 'required|strong_password', ], 'password_confirm' => [ 'label' => 'Auth.passwordConfirm', 'rules' => 'required|matches[password]', ], ]; Login Similar to the process for validation rules in the Registration section, you can add rules for the login form to app/Config/Validation.php and change the rules. //-------------------------------------------------------------------- // Rules For Login //-------------------------------------------------------------------- public $login = [ // 'username' => [ // 'label' => 'Auth.username', // 'rules' => 'required|max_length[30]|min_length[3]|regex_match[/\\A[a-zA-Z0-9\\.]+\\z/]', // ], 'email' => [ 'label' => 'Auth.email', 'rules' => 'required|max_length[254]|valid_email', ], 'password' => [ 'label' => 'Auth.password', 'rules' => 'required', ], ];","title":"Customization"},{"location":"customization/#customizing-shield","text":"Customizing Shield Route Configuration Custom Redirect URLs Extending the Controllers Custom Validation Rules Registration Login","title":"Customizing Shield"},{"location":"customization/#route-configuration","text":"If you need to customize how any of the auth features are handled, you will likely need to update the routes to point to the correct controllers. You can still use the service('auth')->routes() helper, but you will need to pass the except option with a list of routes to customize: service('auth')->routes($routes, ['except' => ['login', 'register']]); Then add the routes to your customized controllers: $routes->get('login', '\\App\\Controllers\\Auth\\LoginController::loginView'); $routes->get('register', '\\App\\Controllers\\Auth\\RegisterController::registerView');","title":"Route Configuration"},{"location":"customization/#custom-redirect-urls","text":"By default, a successful login or register attempt will all redirect to / , while a logout action will redirect to /login . You can change the default URLs used within the Auth config file: public array $redirects = [ 'register' => '/', 'login' => '/', 'logout' => 'login', ]; Oftentimes, you will want to have different redirects for different user groups. A simple example might be that you want admins redirected to /admin while all other groups redirect to / . The Auth config file also includes methods that you can add additional logic to in order to achieve this: public function loginRedirect(): string { if (auth()->user()->can('admin.access')) { return '/admin'; } $url = setting('Auth.redirects')['login']; return $this->getUrl($url); }","title":"Custom Redirect URLs"},{"location":"customization/#extending-the-controllers","text":"Shield has the following controllers that can be extended to handle various parts of the authentication process: ActionController handles the after-login and after-registration actions, like Two Factor Authentication and Email Verification. LoginController handles the login process. RegisterController handles the registration process. Overriding this class allows you to customize the User Provider, the User Entity, and the validation rules. MagicLinkController handles the \"lost password\" process that allows a user to login with a link sent to their email. This allows you to override the message that is displayed to a user to describe what is happening, if you'd like to provide more information than simply swapping out the view used. It is not recommended to copy the entire controller into app/Controllers and change its namespace. Instead, you should create a new controller that extends the existing controller and then only override the methods needed. This allows the other methods to stay up to date with any security updates that might happen in the controllers. <?php namespace App\\Controllers; use CodeIgniter\\Shield\\Controllers\\LoginController as ShieldLogin; class LoginController extends ShieldLogin { public function logoutAction() { // new functionality } }","title":"Extending the Controllers"},{"location":"customization/#custom-validation-rules","text":"","title":"Custom Validation Rules"},{"location":"customization/#registration","text":"Shield has the following rules for registration: [ 'username' => [ 'label' => 'Auth.username', 'rules' => 'required|max_length[30]|min_length[3]|regex_match[/\\A[a-zA-Z0-9\\.]+\\z/]|is_unique[users.username]', ], 'email' => [ 'label' => 'Auth.email', 'rules' => 'required|max_length[254]|valid_email|is_unique[auth_identities.secret]', ], 'password' => [ 'label' => 'Auth.password', 'rules' => 'required|strong_password', ], 'password_confirm' => [ 'label' => 'Auth.passwordConfirm', 'rules' => 'required|matches[password]', ], ]; If you need a different set of rules for registration, you can specify them in your Validation configuration ( app/Config/Validation.php ) like: //-------------------------------------------------------------------- // Rules For Registration //-------------------------------------------------------------------- public $registration = [ 'username' => [ 'label' => 'Auth.username', 'rules' => 'required|max_length[30]|min_length[3]|regex_match[/\\A[a-zA-Z0-9\\.]+\\z/]|is_unique[users.username]', ], 'email' => [ 'label' => 'Auth.email', 'rules' => 'required|max_length[254]|valid_email|is_unique[auth_identities.secret]', ], 'password' => [ 'label' => 'Auth.password', 'rules' => 'required|strong_password', ], 'password_confirm' => [ 'label' => 'Auth.passwordConfirm', 'rules' => 'required|matches[password]', ], ];","title":"Registration"},{"location":"customization/#login","text":"Similar to the process for validation rules in the Registration section, you can add rules for the login form to app/Config/Validation.php and change the rules. //-------------------------------------------------------------------- // Rules For Login //-------------------------------------------------------------------- public $login = [ // 'username' => [ // 'label' => 'Auth.username', // 'rules' => 'required|max_length[30]|min_length[3]|regex_match[/\\A[a-zA-Z0-9\\.]+\\z/]', // ], 'email' => [ 'label' => 'Auth.email', 'rules' => 'required|max_length[254]|valid_email', ], 'password' => [ 'label' => 'Auth.password', 'rules' => 'required', ], ];","title":"Login"},{"location":"events/","text":"Events Shield fires off several events during the lifecycle of the application that your code can tap into. Events Responding to Events Event List register login failedLogin logout magicLogin Event Timing Responding to Events When you want to respond to an event that Shield publishes, you will need to add it to your app/Config/Events.php file. Each of the following events provides a sample for responding that uses a class and method name. Other methods are available. See the CodeIgniter 4 User Guide for more information. Event List register Triggered when a new user has registered in the system. It's only argument is the User entity itself. Events::trigger('register', $user); Events::on('register', 'SomeLibrary::handleRegister'); login Fired immediately after a successful login. The only argument is the User entity. Events::trigger('login', $user); Events::on('login', 'SomeLibrary::handleLogin'); failedLogin Triggered when a login attempt fails. It provides an array containing the credentials the user attempted to sign in with, with the password removed from the array. // Original credentials array $credentials = ['email' => 'foo@example.com', 'password' => 'secret123']; Events::on('failedLogin', function($credentials) { dd($credentials); }); // Outputs: ['email' => 'foo@example.com']; When the magic link login fails, the following array will be provided: ['magicLinkToken' => 'the token value used'] logout Fired immediately after a successful logout. The only argument is the User entity. magicLogin Fired when a user has been successfully logged in via a magic link. This event does not have any parameters passed in. The authenticated user can be discovered through the auth() helper. Events::on('magicLogin', function() { $user = auth()->user(); // }) Event Timing To learn more about Event timing, please see the list below. Session Authenticator Event and Logging .","title":"Events"},{"location":"events/#events","text":"Shield fires off several events during the lifecycle of the application that your code can tap into. Events Responding to Events Event List register login failedLogin logout magicLogin Event Timing","title":"Events"},{"location":"events/#responding-to-events","text":"When you want to respond to an event that Shield publishes, you will need to add it to your app/Config/Events.php file. Each of the following events provides a sample for responding that uses a class and method name. Other methods are available. See the CodeIgniter 4 User Guide for more information.","title":"Responding to Events"},{"location":"events/#event-list","text":"","title":"Event List"},{"location":"events/#register","text":"Triggered when a new user has registered in the system. It's only argument is the User entity itself. Events::trigger('register', $user); Events::on('register', 'SomeLibrary::handleRegister');","title":"register"},{"location":"events/#login","text":"Fired immediately after a successful login. The only argument is the User entity. Events::trigger('login', $user); Events::on('login', 'SomeLibrary::handleLogin');","title":"login"},{"location":"events/#failedlogin","text":"Triggered when a login attempt fails. It provides an array containing the credentials the user attempted to sign in with, with the password removed from the array. // Original credentials array $credentials = ['email' => 'foo@example.com', 'password' => 'secret123']; Events::on('failedLogin', function($credentials) { dd($credentials); }); // Outputs: ['email' => 'foo@example.com']; When the magic link login fails, the following array will be provided: ['magicLinkToken' => 'the token value used']","title":"failedLogin"},{"location":"events/#logout","text":"Fired immediately after a successful logout. The only argument is the User entity.","title":"logout"},{"location":"events/#magiclogin","text":"Fired when a user has been successfully logged in via a magic link. This event does not have any parameters passed in. The authenticated user can be discovered through the auth() helper. Events::on('magicLogin', function() { $user = auth()->user(); // })","title":"magicLogin"},{"location":"events/#event-timing","text":"To learn more about Event timing, please see the list below. Session Authenticator Event and Logging .","title":"Event Timing"},{"location":"install/","text":"Installation Installation Requirements Composer Installation Troubleshooting IMPORTANT: composer error Initial Setup Command Setup Manual Setup Controller Filters Protect All Pages Rate Limiting These instructions assume that you have already installed the CodeIgniter 4 app starter as the basis for your new project, set up your .env file, and created a database that you can access via the Spark CLI script. Requirements Composer Codeigniter v4.2.3 or later A created database that you can access via the Spark CLI script Composer Installation Installation is done through Composer . The example assumes you have it installed globally. If you have it installed as a phar, or otherwise you will need to adjust the way you call composer itself. > composer require codeigniter4/shield Troubleshooting IMPORTANT: composer error If you get the following error: Could not find a version of package codeigniter4/shield matching your minimum-stability (stable). Require it with an explicit version constraint allowing its desired stability. Add the following to change your minimum-stability in your project composer.json : \"minimum-stability\": \"dev\", \"prefer-stable\": true, Or specify an explicit version: > composer require codeigniter4/shield:dev-develop The above specifies develop branch. See https://getcomposer.org/doc/articles/versions.md#branches > composer require codeigniter4/shield:^1.0.0-beta The above specifies v1.0.0-beta or later and before v2.0.0 . See https://getcomposer.org/doc/articles/versions.md#caret-version-range- Initial Setup Command Setup Run the following command. This command handles steps 1-5 of Manual Setup and runs the migrations. > php spark shield:setup Manual Setup There are a few setup items to do before you can start using Shield in your project. Copy the Auth.php and AuthGroups.php from vendor/codeigniter4/shield/src/Config/ into your project's config folder and update the namespace to Config . You will also need to have these classes extend the original classes. See the example below. These files contain all of the settings, group, and permission information for your application and will need to be modified to meet the needs of your site. // new file - app/Config/Auth.php <?php namespace Config; // ... use CodeIgniter\\Shield\\Config\\Auth as ShieldAuth; class Auth extends ShieldAuth { // ... } Helper Setup The setting helper needs to be included in almost every page. The simplest way to do this is to add it to the BaseController::initController method: public function initController(RequestInterface $request, ResponseInterface $response, LoggerInterface $logger) { $this->helpers = array_merge($this->helpers, ['setting']); // Do Not Edit This Line parent::initController($request, $response, $logger); } This requires that all of your controllers extend the BaseController , but that's a good practice anyway. Routes Setup The default auth routes can be setup with a single call in app/Config/Routes.php : service('auth')->routes($routes); Security Setup Set Config\\Security::$csrfProtection to 'session' (or set security.csrfProtection = session in your .env file) for security reasons, if you use Session Authenticator. Migration Run the migrations. > php spark migrate --all Note: migration error When you run spark migrate --all , if you get Class \"SQLite3\" not found error: Remove sample migration files in tests/_support/Database/Migrations/ Or install sqlite3 php extension If you get Specified key was too long error: Use InnoDB, not MyISAM. Controller Filters Shield provides 4 Controller Filters you can use to protect your routes, session , tokens , and chained . The first two cover the Session and AccessTokens authenticators, respectively. The chained filter will check both authenticators in sequence to see if the user is logged in through either of authenticators, allowing a single API endpoint to work for both an SPA using session auth, and a mobile app using access tokens. The fourth, auth-rates , provides a good basis for rate limiting of auth-related routes. These can be used in any of the normal filter config settings , or within the routes file . Protect All Pages If you want to limit all routes (e.g. localhost:8080/admin , localhost:8080/panel and ...), you need to add the following code in the app/Config/Filters.php file. public $globals = [ 'before' => [ // ... 'session' => ['except' => ['login*', 'register', 'auth/a/*']], ], // ... ]; Note These filters are already loaded for you by the registrar class located at src/Config/Registrar.php . public $aliases = [ // ... 'session' => \\CodeIgniter\\Shield\\Filters\\SessionAuth::class, 'tokens' => \\CodeIgniter\\Shield\\Filters\\TokenAuth::class, 'chain' => \\CodeIgniter\\Shield\\Filters\\ChainAuth::class, 'auth-rates' => \\CodeIgniter\\Shield\\Filters\\AuthRates::class, ]; Rate Limiting To help protect your authentication forms from being spammed by bots, it is recommended that you use the auth-rates filter on all of your authentication routes. This can be done with the following filter setup: public $filters = [ 'auth-rates' => [ 'before' => [ 'login*', 'register', 'auth/*' ] ] ];","title":"Installation"},{"location":"install/#installation","text":"Installation Requirements Composer Installation Troubleshooting IMPORTANT: composer error Initial Setup Command Setup Manual Setup Controller Filters Protect All Pages Rate Limiting These instructions assume that you have already installed the CodeIgniter 4 app starter as the basis for your new project, set up your .env file, and created a database that you can access via the Spark CLI script.","title":"Installation"},{"location":"install/#requirements","text":"Composer Codeigniter v4.2.3 or later A created database that you can access via the Spark CLI script","title":"Requirements"},{"location":"install/#composer-installation","text":"Installation is done through Composer . The example assumes you have it installed globally. If you have it installed as a phar, or otherwise you will need to adjust the way you call composer itself. > composer require codeigniter4/shield","title":"Composer Installation"},{"location":"install/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"install/#important-composer-error","text":"If you get the following error: Could not find a version of package codeigniter4/shield matching your minimum-stability (stable). Require it with an explicit version constraint allowing its desired stability. Add the following to change your minimum-stability in your project composer.json : \"minimum-stability\": \"dev\", \"prefer-stable\": true, Or specify an explicit version: > composer require codeigniter4/shield:dev-develop The above specifies develop branch. See https://getcomposer.org/doc/articles/versions.md#branches > composer require codeigniter4/shield:^1.0.0-beta The above specifies v1.0.0-beta or later and before v2.0.0 . See https://getcomposer.org/doc/articles/versions.md#caret-version-range-","title":"IMPORTANT: composer error"},{"location":"install/#initial-setup","text":"","title":"Initial Setup"},{"location":"install/#command-setup","text":"Run the following command. This command handles steps 1-5 of Manual Setup and runs the migrations. > php spark shield:setup","title":"Command Setup"},{"location":"install/#manual-setup","text":"There are a few setup items to do before you can start using Shield in your project. Copy the Auth.php and AuthGroups.php from vendor/codeigniter4/shield/src/Config/ into your project's config folder and update the namespace to Config . You will also need to have these classes extend the original classes. See the example below. These files contain all of the settings, group, and permission information for your application and will need to be modified to meet the needs of your site. // new file - app/Config/Auth.php <?php namespace Config; // ... use CodeIgniter\\Shield\\Config\\Auth as ShieldAuth; class Auth extends ShieldAuth { // ... } Helper Setup The setting helper needs to be included in almost every page. The simplest way to do this is to add it to the BaseController::initController method: public function initController(RequestInterface $request, ResponseInterface $response, LoggerInterface $logger) { $this->helpers = array_merge($this->helpers, ['setting']); // Do Not Edit This Line parent::initController($request, $response, $logger); } This requires that all of your controllers extend the BaseController , but that's a good practice anyway. Routes Setup The default auth routes can be setup with a single call in app/Config/Routes.php : service('auth')->routes($routes); Security Setup Set Config\\Security::$csrfProtection to 'session' (or set security.csrfProtection = session in your .env file) for security reasons, if you use Session Authenticator. Migration Run the migrations. > php spark migrate --all","title":"Manual Setup"},{"location":"install/#note-migration-error","text":"When you run spark migrate --all , if you get Class \"SQLite3\" not found error: Remove sample migration files in tests/_support/Database/Migrations/ Or install sqlite3 php extension If you get Specified key was too long error: Use InnoDB, not MyISAM.","title":"Note: migration error"},{"location":"install/#controller-filters","text":"Shield provides 4 Controller Filters you can use to protect your routes, session , tokens , and chained . The first two cover the Session and AccessTokens authenticators, respectively. The chained filter will check both authenticators in sequence to see if the user is logged in through either of authenticators, allowing a single API endpoint to work for both an SPA using session auth, and a mobile app using access tokens. The fourth, auth-rates , provides a good basis for rate limiting of auth-related routes. These can be used in any of the normal filter config settings , or within the routes file .","title":"Controller Filters"},{"location":"install/#protect-all-pages","text":"If you want to limit all routes (e.g. localhost:8080/admin , localhost:8080/panel and ...), you need to add the following code in the app/Config/Filters.php file. public $globals = [ 'before' => [ // ... 'session' => ['except' => ['login*', 'register', 'auth/a/*']], ], // ... ]; Note These filters are already loaded for you by the registrar class located at src/Config/Registrar.php . public $aliases = [ // ... 'session' => \\CodeIgniter\\Shield\\Filters\\SessionAuth::class, 'tokens' => \\CodeIgniter\\Shield\\Filters\\TokenAuth::class, 'chain' => \\CodeIgniter\\Shield\\Filters\\ChainAuth::class, 'auth-rates' => \\CodeIgniter\\Shield\\Filters\\AuthRates::class, ];","title":"Protect All Pages"},{"location":"install/#rate-limiting","text":"To help protect your authentication forms from being spammed by bots, it is recommended that you use the auth-rates filter on all of your authentication routes. This can be done with the following filter setup: public $filters = [ 'auth-rates' => [ 'before' => [ 'login*', 'register', 'auth/*' ] ] ];","title":"Rate Limiting"},{"location":"quickstart/","text":"Quick Start Guide Learning any new authentication system can be difficult, especially as they get more flexible and sophisticated. This guide is intended to provide short examples for common actions you'll take when working with Shield. It is not intended to be the exhaustive documentation for each section. That's better handled through the area-specific doc files. NOTE: The examples assume that you have run the setup script and that you have copies of the Auth and AuthGroups config files in your application's app/Config folder. Quick Start Guide Authentication Flow Customize register redirect Customize login redirect Customize logout redirect Customize Remember-me functionality Change Access Token Lifetime Enable Account Activation via Email Enable Two-Factor Authentication Responding to Magic Link Logins Session Notification Event Authorization Flow Change Available Groups Set the Default Group Change Available Permissions Assign Permissions to a Group Assign Permissions to a User Check If a User Has Permission Adding A Group To A User Removing A Group From A User Checking If User Belongs To A Group Managing Users Creating Users Deleting Users Editing A User Authentication Flow If you need everyone to redirect to a single URL after login/logout/register actions, you can modify the Config\\Auth::redirects array to specify the url to redirect to. public array $redirects = [ 'register' => '/', 'login' => '/', 'logout' => 'login', ]; NOTE: This redirect happens after the specified action is complete. In the case of register or login, it might not happen immediately. For example, if you have any Auth Actions specified, they will be redirected when those actions are completed successfully. If no Auth Actions are specified, they will be redirected immediately after registration or login. Customize register redirect You can customize where a user is redirected to after registration in the registerRedirect method of the Auth config file. public function registerRedirect(): string { $url = setting('Auth.redirects')['register']; return $this->getUrl($url); } Customize login redirect You can further customize where a user is redirected to on login with the loginRedirect method of the Auth config file. This is handy if you want to redirect based on user group or other criteria. public function loginRedirect(): string { $url = auth()->user()->inGroup('admin') ? '/admin' : setting('Auth.redirects')['login']; return $this->getUrl($url); } Customize logout redirect The logout redirect can also be overridden by the logoutRedirect method of the Auth config file. This will not be used as often as login and register, but you might find the need. For example, if you programatically logged a user out you might want to take them to a page that specifies why they were logged out. Otherwise, you might take them to the home page or even the login page. public function logoutRedirect(): string { $url = setting('Auth.redirects')['logout']; return $this->getUrl($url); } Customize Remember-me functionality Remember-me functionality is enabled by default for the Session handler. While this is handled in a secure manner, some sites may want it disabled. You might also want to change how long it remembers a user and doesn't require additional login. public array $sessionConfig = [ 'field' => 'user', 'allowRemembering' => true, 'rememberCookieName' => 'remember', 'rememberLength' => 30 * DAY, ]; Change Access Token Lifetime By default, Access Tokens can be used for 1 year since the last use. This can be easily modified in the Auth config file. public int $unusedTokenLifetime = YEAR; Enable Account Activation via Email By default, once a user registers they have an active account that can be used. You can enable Shield's built-in, email-based activation flow within the Auth config file. public array $actions = [ 'register' => 'CodeIgniter\\Shield\\Authentication\\Actions\\EmailActivator', 'login' => null, ]; Enable Two-Factor Authentication Turned off by default, Shield's Email-based 2FA can be enabled by specifying the class to use in the Auth config file. public array $actions = [ 'register' => null, 'login' => 'CodeIgniter\\Shield\\Authentication\\Actions\\Email2FA', ]; Responding to Magic Link Logins Magic Link logins allow a user that has forgotten their password to have an email sent with a unique, one-time login link. Once they've logged in you can decide how to respond. In some cases, you might want to redirect them to a special page where they must choose a new password. In other cases, you might simply want to display a one-time message prompting them to go to their account page and choose a new password. Session Notification You can detect if a user has finished the magic link login by checking for a session value, magicLogin . If they have recently completed the flow, it will exist and have a value of true . if (session('magicLogin')) { return redirect()->route('set_password'); } This value sticks around in the session for 5 minutes. Once you no longer need to take any actions, you might want to delete the value from the session. session()->removeTempdata('magicLogin'); Event At the same time the above session variable is set, a magicLogin event is fired off that you may subscribe to. Note that no data is passed to the event as you can easily grab the current user from the user() helper or the auth()->user() method. Events::on('magicLogin', static function () { // ... }); Authorization Flow Change Available Groups The available groups are defined in the AuthGroups config file, under the $groups property. Add new entries to the array, or remove existing ones to make them available throughout your application. public array $groups = [ 'superadmin' => [ 'title' => 'Super Admin', 'description' => 'Complete control of the site.', ], // ]; Set the Default Group When a user registers on your site, they are assigned the group specified at Config\\AuthGroups::$defaultGroup . Change this to one of the keys in the $groups array to update this. Change Available Permissions The permissions on the site are stored in the AuthGroups config file also. Each one is defined by a string that represents a context and a permission, joined with a decimal point. public array $permissions = [ 'admin.access' => 'Can access the sites admin area', 'admin.settings' => 'Can access the main site settings', 'users.manage-admins' => 'Can manage other admins', 'users.create' => 'Can create new non-admin users', 'users.edit' => 'Can edit existing non-admin users', 'users.delete' => 'Can delete existing non-admin users', 'beta.access' => 'Can access beta-level features', ]; Assign Permissions to a Group Each group can have its own specific set of permissions. These are defined in Config\\AuthGroups::$matrix . You can specify each permission by it's full name, or using the context and an asterisk (*) to specify all permissions within that context. public array $matrix = [ 'superadmin' => [ 'admin.*', 'users.*', 'beta.access', ], // ]; Assign Permissions to a User Permissions can also be assigned directly to a user, regardless of what groups they belong to. This is done programatically on the User Entity. $user = auth()->user(); $user->addPermission('users.create', 'beta.access'); This will add all new permissions. You can also sync permissions so that the user ONLY has the given permissions directly assigned to them. Any not in the provided list are removed from the user. $user = auth()->user(); $user->syncPermissions('users.create', 'beta.access'); Check If a User Has Permission When you need to check if a user has a specific permission use the can() method on the User entity. This method checks permissions within the groups they belong to and permissions directly assigned to the user. if (! auth()->user()->can('users.create')) { return redirect()->back()->with('error', 'You do not have permissions to access that page.'); } Note: The example above can also be done through a controller filter if you want to apply it to multiple pages of your site. Adding A Group To A User Groups are assigned to a user via the addGroup method. You can pass multiple groups in and they will all be assigned to the user. $user = auth()->user(); $user->addGroup('admin', 'beta'); This will add all new groups. You can also sync groups so that the user ONLY belongs to the groups directly assigned to them. Any not in the provided list are removed from the user. $user = auth()->user(); $user->syncGroups('admin', 'beta'); Removing A Group From A User Groups are removed from a user via the removeGroup method. Multiple groups may be removed at once by passing all of their names into the method. $user = auth()->user(); $user->removeGroup('admin', 'beta'); Checking If User Belongs To A Group You can check if a user belongs to a group with the inGroup method. $user = auth()->user(); if ($user->inGroup('admin')) { // do something } You can pass more than one group to the method and it will return true if the user belongs to any of the specified groups. $user = auth()->user(); if ($user->inGroup('admin', 'beta')) { // do something } Managing Users Since Shield uses a more complex user setup than many other systems, separating User Identities from the user accounts themselves. This quick overview should help you feel more confident when working with users on a day-to-day basis. Creating Users By default, the only values stored in the users table is the username. The first step is to create the user record with the username. If you don't have a username, be sure to set the value to null anyway, so that it passes CodeIgniter's empty data check. use CodeIgniter\\Shield\\Entities\\User; $users = model('UserModel'); $user = new User([ 'username' => 'foo-bar', 'email' => 'foo.bar@example.com', 'password' => 'secret plain text password', ]); $users->save($user); // To get the complete user object with ID, we need to get from the database $user = $users->findById($users->getInsertID()); // Add to default group $users->addToDefaultGroup($user); Deleting Users A user's data can be spread over a few different tables so you might be concerned about how to delete all of the user's data from the system. This is handled automatically at the database level for all information that Shield knows about, through the onCascade settings of the table's foreign keys. You can delete a user like any other entity. $users = model('UserModel'); $users->delete($user->id, true); NOTE: The User rows use soft deletes so they are not actually deleted from the database unless the second parameter is true , like above. Editing A User The UserModel::save() , update() and insert() methods have been modified to ensure that an email or password previously set on the User entity will be automatically updated in the correct UserIdentity record. $users = model('UserModel'); $user = $users->findById(123); $user->fill([ 'username' => 'JoeSmith111', 'email' => 'joe.smith@example.com', 'password' => 'secret123' ]); $users->save($user);","title":"Quick Start Guide"},{"location":"quickstart/#quick-start-guide","text":"Learning any new authentication system can be difficult, especially as they get more flexible and sophisticated. This guide is intended to provide short examples for common actions you'll take when working with Shield. It is not intended to be the exhaustive documentation for each section. That's better handled through the area-specific doc files. NOTE: The examples assume that you have run the setup script and that you have copies of the Auth and AuthGroups config files in your application's app/Config folder. Quick Start Guide Authentication Flow Customize register redirect Customize login redirect Customize logout redirect Customize Remember-me functionality Change Access Token Lifetime Enable Account Activation via Email Enable Two-Factor Authentication Responding to Magic Link Logins Session Notification Event Authorization Flow Change Available Groups Set the Default Group Change Available Permissions Assign Permissions to a Group Assign Permissions to a User Check If a User Has Permission Adding A Group To A User Removing A Group From A User Checking If User Belongs To A Group Managing Users Creating Users Deleting Users Editing A User","title":"Quick Start Guide"},{"location":"quickstart/#authentication-flow","text":"If you need everyone to redirect to a single URL after login/logout/register actions, you can modify the Config\\Auth::redirects array to specify the url to redirect to. public array $redirects = [ 'register' => '/', 'login' => '/', 'logout' => 'login', ]; NOTE: This redirect happens after the specified action is complete. In the case of register or login, it might not happen immediately. For example, if you have any Auth Actions specified, they will be redirected when those actions are completed successfully. If no Auth Actions are specified, they will be redirected immediately after registration or login.","title":"Authentication Flow"},{"location":"quickstart/#customize-register-redirect","text":"You can customize where a user is redirected to after registration in the registerRedirect method of the Auth config file. public function registerRedirect(): string { $url = setting('Auth.redirects')['register']; return $this->getUrl($url); }","title":"Customize register redirect"},{"location":"quickstart/#customize-login-redirect","text":"You can further customize where a user is redirected to on login with the loginRedirect method of the Auth config file. This is handy if you want to redirect based on user group or other criteria. public function loginRedirect(): string { $url = auth()->user()->inGroup('admin') ? '/admin' : setting('Auth.redirects')['login']; return $this->getUrl($url); }","title":"Customize login redirect"},{"location":"quickstart/#customize-logout-redirect","text":"The logout redirect can also be overridden by the logoutRedirect method of the Auth config file. This will not be used as often as login and register, but you might find the need. For example, if you programatically logged a user out you might want to take them to a page that specifies why they were logged out. Otherwise, you might take them to the home page or even the login page. public function logoutRedirect(): string { $url = setting('Auth.redirects')['logout']; return $this->getUrl($url); }","title":"Customize logout redirect"},{"location":"quickstart/#customize-remember-me-functionality","text":"Remember-me functionality is enabled by default for the Session handler. While this is handled in a secure manner, some sites may want it disabled. You might also want to change how long it remembers a user and doesn't require additional login. public array $sessionConfig = [ 'field' => 'user', 'allowRemembering' => true, 'rememberCookieName' => 'remember', 'rememberLength' => 30 * DAY, ];","title":"Customize Remember-me functionality"},{"location":"quickstart/#change-access-token-lifetime","text":"By default, Access Tokens can be used for 1 year since the last use. This can be easily modified in the Auth config file. public int $unusedTokenLifetime = YEAR;","title":"Change Access Token Lifetime"},{"location":"quickstart/#enable-account-activation-via-email","text":"By default, once a user registers they have an active account that can be used. You can enable Shield's built-in, email-based activation flow within the Auth config file. public array $actions = [ 'register' => 'CodeIgniter\\Shield\\Authentication\\Actions\\EmailActivator', 'login' => null, ];","title":"Enable Account Activation via Email"},{"location":"quickstart/#enable-two-factor-authentication","text":"Turned off by default, Shield's Email-based 2FA can be enabled by specifying the class to use in the Auth config file. public array $actions = [ 'register' => null, 'login' => 'CodeIgniter\\Shield\\Authentication\\Actions\\Email2FA', ];","title":"Enable Two-Factor Authentication"},{"location":"quickstart/#responding-to-magic-link-logins","text":"Magic Link logins allow a user that has forgotten their password to have an email sent with a unique, one-time login link. Once they've logged in you can decide how to respond. In some cases, you might want to redirect them to a special page where they must choose a new password. In other cases, you might simply want to display a one-time message prompting them to go to their account page and choose a new password.","title":"Responding to Magic Link Logins"},{"location":"quickstart/#session-notification","text":"You can detect if a user has finished the magic link login by checking for a session value, magicLogin . If they have recently completed the flow, it will exist and have a value of true . if (session('magicLogin')) { return redirect()->route('set_password'); } This value sticks around in the session for 5 minutes. Once you no longer need to take any actions, you might want to delete the value from the session. session()->removeTempdata('magicLogin');","title":"Session Notification"},{"location":"quickstart/#event","text":"At the same time the above session variable is set, a magicLogin event is fired off that you may subscribe to. Note that no data is passed to the event as you can easily grab the current user from the user() helper or the auth()->user() method. Events::on('magicLogin', static function () { // ... });","title":"Event"},{"location":"quickstart/#authorization-flow","text":"","title":"Authorization Flow"},{"location":"quickstart/#change-available-groups","text":"The available groups are defined in the AuthGroups config file, under the $groups property. Add new entries to the array, or remove existing ones to make them available throughout your application. public array $groups = [ 'superadmin' => [ 'title' => 'Super Admin', 'description' => 'Complete control of the site.', ], // ];","title":"Change Available Groups"},{"location":"quickstart/#set-the-default-group","text":"When a user registers on your site, they are assigned the group specified at Config\\AuthGroups::$defaultGroup . Change this to one of the keys in the $groups array to update this.","title":"Set the Default Group"},{"location":"quickstart/#change-available-permissions","text":"The permissions on the site are stored in the AuthGroups config file also. Each one is defined by a string that represents a context and a permission, joined with a decimal point. public array $permissions = [ 'admin.access' => 'Can access the sites admin area', 'admin.settings' => 'Can access the main site settings', 'users.manage-admins' => 'Can manage other admins', 'users.create' => 'Can create new non-admin users', 'users.edit' => 'Can edit existing non-admin users', 'users.delete' => 'Can delete existing non-admin users', 'beta.access' => 'Can access beta-level features', ];","title":"Change Available Permissions"},{"location":"quickstart/#assign-permissions-to-a-group","text":"Each group can have its own specific set of permissions. These are defined in Config\\AuthGroups::$matrix . You can specify each permission by it's full name, or using the context and an asterisk (*) to specify all permissions within that context. public array $matrix = [ 'superadmin' => [ 'admin.*', 'users.*', 'beta.access', ], // ];","title":"Assign Permissions to a Group"},{"location":"quickstart/#assign-permissions-to-a-user","text":"Permissions can also be assigned directly to a user, regardless of what groups they belong to. This is done programatically on the User Entity. $user = auth()->user(); $user->addPermission('users.create', 'beta.access'); This will add all new permissions. You can also sync permissions so that the user ONLY has the given permissions directly assigned to them. Any not in the provided list are removed from the user. $user = auth()->user(); $user->syncPermissions('users.create', 'beta.access');","title":"Assign Permissions to a User"},{"location":"quickstart/#check-if-a-user-has-permission","text":"When you need to check if a user has a specific permission use the can() method on the User entity. This method checks permissions within the groups they belong to and permissions directly assigned to the user. if (! auth()->user()->can('users.create')) { return redirect()->back()->with('error', 'You do not have permissions to access that page.'); } Note: The example above can also be done through a controller filter if you want to apply it to multiple pages of your site.","title":"Check If a User Has Permission"},{"location":"quickstart/#adding-a-group-to-a-user","text":"Groups are assigned to a user via the addGroup method. You can pass multiple groups in and they will all be assigned to the user. $user = auth()->user(); $user->addGroup('admin', 'beta'); This will add all new groups. You can also sync groups so that the user ONLY belongs to the groups directly assigned to them. Any not in the provided list are removed from the user. $user = auth()->user(); $user->syncGroups('admin', 'beta');","title":"Adding A Group To A User"},{"location":"quickstart/#removing-a-group-from-a-user","text":"Groups are removed from a user via the removeGroup method. Multiple groups may be removed at once by passing all of their names into the method. $user = auth()->user(); $user->removeGroup('admin', 'beta');","title":"Removing A Group From A User"},{"location":"quickstart/#checking-if-user-belongs-to-a-group","text":"You can check if a user belongs to a group with the inGroup method. $user = auth()->user(); if ($user->inGroup('admin')) { // do something } You can pass more than one group to the method and it will return true if the user belongs to any of the specified groups. $user = auth()->user(); if ($user->inGroup('admin', 'beta')) { // do something }","title":"Checking If User Belongs To A Group"},{"location":"quickstart/#managing-users","text":"Since Shield uses a more complex user setup than many other systems, separating User Identities from the user accounts themselves. This quick overview should help you feel more confident when working with users on a day-to-day basis.","title":"Managing Users"},{"location":"quickstart/#creating-users","text":"By default, the only values stored in the users table is the username. The first step is to create the user record with the username. If you don't have a username, be sure to set the value to null anyway, so that it passes CodeIgniter's empty data check. use CodeIgniter\\Shield\\Entities\\User; $users = model('UserModel'); $user = new User([ 'username' => 'foo-bar', 'email' => 'foo.bar@example.com', 'password' => 'secret plain text password', ]); $users->save($user); // To get the complete user object with ID, we need to get from the database $user = $users->findById($users->getInsertID()); // Add to default group $users->addToDefaultGroup($user);","title":"Creating Users"},{"location":"quickstart/#deleting-users","text":"A user's data can be spread over a few different tables so you might be concerned about how to delete all of the user's data from the system. This is handled automatically at the database level for all information that Shield knows about, through the onCascade settings of the table's foreign keys. You can delete a user like any other entity. $users = model('UserModel'); $users->delete($user->id, true); NOTE: The User rows use soft deletes so they are not actually deleted from the database unless the second parameter is true , like above.","title":"Deleting Users"},{"location":"quickstart/#editing-a-user","text":"The UserModel::save() , update() and insert() methods have been modified to ensure that an email or password previously set on the User entity will be automatically updated in the correct UserIdentity record. $users = model('UserModel'); $user = $users->findById(123); $user->fill([ 'username' => 'JoeSmith111', 'email' => 'joe.smith@example.com', 'password' => 'secret123' ]); $users->save($user);","title":"Editing A User"},{"location":"session_auth_event_and_logging/","text":"Session Authenticator Event and Logging The following is a list of Events and Logging for Session Authenticator. Register Default Register Post email/username/password OK \u2192 event register and login NG \u2192 no event Register with Email Activation Post email/username/password OK \u2192 event register NG \u2192 no event Post token OK \u2192 event login NG \u2192 no event Login Default Login Post email/password OK \u2192 event login / table auth_logins NG \u2192 event failedLogin / table auth_logins Email2FA Login Post email/password OK \u2192 no event / table auth_logins NG \u2192 event failedLogin / table auth_logins Post token OK \u2192 event login NG \u2192 no event Remember-me Send remember-me cookie w/o session cookie OK \u2192 no event NG \u2192 no event Magic-link Post email OK \u2192 no event NG \u2192 no event Send request with token OK \u2192 event login and magicLogin / table auth_logins NG \u2192 event failedLogin / table auth_logins","title":"Session Authenticator Event and Logging"},{"location":"session_auth_event_and_logging/#session-authenticator-event-and-logging","text":"The following is a list of Events and Logging for Session Authenticator.","title":"Session Authenticator Event and Logging"},{"location":"session_auth_event_and_logging/#register","text":"Default Register Post email/username/password OK \u2192 event register and login NG \u2192 no event Register with Email Activation Post email/username/password OK \u2192 event register NG \u2192 no event Post token OK \u2192 event login NG \u2192 no event","title":"Register"},{"location":"session_auth_event_and_logging/#login","text":"Default Login Post email/password OK \u2192 event login / table auth_logins NG \u2192 event failedLogin / table auth_logins Email2FA Login Post email/password OK \u2192 no event / table auth_logins NG \u2192 event failedLogin / table auth_logins Post token OK \u2192 event login NG \u2192 no event Remember-me Send remember-me cookie w/o session cookie OK \u2192 no event NG \u2192 no event Magic-link Post email OK \u2192 no event NG \u2192 no event Send request with token OK \u2192 event login and magicLogin / table auth_logins NG \u2192 event failedLogin / table auth_logins","title":"Login"},{"location":"testing/","text":"Testing When performing HTTP testing in your applications, you will often need to ensure you are logged in to check security, or simply to access protected locations. Shield provides the AuthenticationTesting trait to help you out. Use it within the test class and then you can use the actingAs() method that takes a User instance. This user will be logged in during the test. <?php use CodeIgniter\\Shield\\Test\\AuthenticationTesting; use Tests\\Support\\TestCase; use CodeIgniter\\Shield\\Authentication\\Actions\\Email2FA; class ActionsTest extends TestCase { use DatabaseTestTrait; use FeatureTestTrait; use AuthenticationTesting; public function testEmail2FAShow() { $result = $this->actingAs($this->user) ->withSession([ 'auth_action' => Email2FA::class, ])->get('/auth/a/show'); $result->assertStatus(200); // Should auto-populate in the form $result->assertSee($this->user->email); } }","title":"Testing"},{"location":"testing/#testing","text":"When performing HTTP testing in your applications, you will often need to ensure you are logged in to check security, or simply to access protected locations. Shield provides the AuthenticationTesting trait to help you out. Use it within the test class and then you can use the actingAs() method that takes a User instance. This user will be logged in during the test. <?php use CodeIgniter\\Shield\\Test\\AuthenticationTesting; use Tests\\Support\\TestCase; use CodeIgniter\\Shield\\Authentication\\Actions\\Email2FA; class ActionsTest extends TestCase { use DatabaseTestTrait; use FeatureTestTrait; use AuthenticationTesting; public function testEmail2FAShow() { $result = $this->actingAs($this->user) ->withSession([ 'auth_action' => Email2FA::class, ])->get('/auth/a/show'); $result->assertStatus(200); // Should auto-populate in the form $result->assertSee($this->user->email); } }","title":"Testing"},{"location":"guides/api_tokens/","text":"Protecting an API with Access Tokens Access Tokens can be used to authenticate users for your own site, or when allowing third-party developers to access your API. When making requests using access tokens, the token should be included in the Authorization header as a Bearer token. Note By default, $authenticatorHeader['tokens'] is set to Authorization . You can change this value by setting the $authenticatorHeader['tokens'] value in the Auth.php config file. Tokens are issued with the generateAccessToken() method on the user. This returns a CodeIgniter\\Shield\\Entities\\AccessToken instance. Tokens are hashed using a SHA-256 algorithm before being saved to the database. The access token returned when you generate it will include a raw_token field that contains the plain-text, un-hashed, token. You should display this to your user at once so they have a chance to copy it somewhere safe, as this is the only time this will be available. After this request, there is no way to get the raw token. The generateAccessToken() method requires a name for the token. These are free strings and are often used to identify the user/device the token was generated from, like 'Johns MacBook Air'. $routes->get('/access/token', static function() { $token = auth()->user()->generateAccessToken(service('request')->getVar('token_name')); return json_encode(['token' => $token->raw_token]); }); You can access all of the user's tokens with the accessTokens() method on that user. $tokens = $user->accessTokens(); foreach($tokens as $token) { // } Token Permissions Access tokens can be given scopes , which are basically permission strings, for the token. This is generally not the same as the permission the user has, but is used to specify the permissions on the API itself. If not specified, the token is granted all access to all scopes. This might be enough for a smaller API. return $user->generateAccessToken('token-name', ['users-read'])->raw_token; Note At this time, scope names should avoid using a colon ( : ) as this causes issues with the route filters being correctly recognized. When handling incoming requests you can check if the token has been granted access to the scope with the tokenCan() method. if ($user->tokenCan('users-read')) { // } Revoking Tokens Tokens can be revoked by deleting them from the database with the revokeAccessToken($rawToken) or revokeAllAccessTokens() methods. $user->revokeAccessToken($rawToken); $user->revokeAllAccessTokens(); Protecting Routes The first way to specify which routes are protected is to use the tokens controller filter. For example, to ensure it protects all routes under the /api route group, you would use the $filters setting on app/Config/Filters.php . public $filters = [ 'tokens' => ['before' => ['api/*']], ]; You can also specify the filter should run on one or more routes within the routes file itself: $routes->group('api', ['filter' => 'tokens'], function($routes) { // }); $routes->get('users', 'UserController::list', ['filter' => 'tokens:users-read']); When the filter runs, it checks the Authorization header for a Bearer value that has the raw token. It then hashes the raw token and looks it up in the database. Once found, it can determine the correct user, which will then be available through an auth()->user() call. Note Currently only a single scope can be used on a route filter. If multiple scopes are passed in, only the first one is checked.","title":"Protecting an API with Access Tokens"},{"location":"guides/api_tokens/#protecting-an-api-with-access-tokens","text":"Access Tokens can be used to authenticate users for your own site, or when allowing third-party developers to access your API. When making requests using access tokens, the token should be included in the Authorization header as a Bearer token. Note By default, $authenticatorHeader['tokens'] is set to Authorization . You can change this value by setting the $authenticatorHeader['tokens'] value in the Auth.php config file. Tokens are issued with the generateAccessToken() method on the user. This returns a CodeIgniter\\Shield\\Entities\\AccessToken instance. Tokens are hashed using a SHA-256 algorithm before being saved to the database. The access token returned when you generate it will include a raw_token field that contains the plain-text, un-hashed, token. You should display this to your user at once so they have a chance to copy it somewhere safe, as this is the only time this will be available. After this request, there is no way to get the raw token. The generateAccessToken() method requires a name for the token. These are free strings and are often used to identify the user/device the token was generated from, like 'Johns MacBook Air'. $routes->get('/access/token', static function() { $token = auth()->user()->generateAccessToken(service('request')->getVar('token_name')); return json_encode(['token' => $token->raw_token]); }); You can access all of the user's tokens with the accessTokens() method on that user. $tokens = $user->accessTokens(); foreach($tokens as $token) { // }","title":"Protecting an API with Access Tokens"},{"location":"guides/api_tokens/#token-permissions","text":"Access tokens can be given scopes , which are basically permission strings, for the token. This is generally not the same as the permission the user has, but is used to specify the permissions on the API itself. If not specified, the token is granted all access to all scopes. This might be enough for a smaller API. return $user->generateAccessToken('token-name', ['users-read'])->raw_token; Note At this time, scope names should avoid using a colon ( : ) as this causes issues with the route filters being correctly recognized. When handling incoming requests you can check if the token has been granted access to the scope with the tokenCan() method. if ($user->tokenCan('users-read')) { // }","title":"Token Permissions"},{"location":"guides/api_tokens/#revoking-tokens","text":"Tokens can be revoked by deleting them from the database with the revokeAccessToken($rawToken) or revokeAllAccessTokens() methods. $user->revokeAccessToken($rawToken); $user->revokeAllAccessTokens();","title":"Revoking Tokens"},{"location":"guides/api_tokens/#protecting-routes","text":"The first way to specify which routes are protected is to use the tokens controller filter. For example, to ensure it protects all routes under the /api route group, you would use the $filters setting on app/Config/Filters.php . public $filters = [ 'tokens' => ['before' => ['api/*']], ]; You can also specify the filter should run on one or more routes within the routes file itself: $routes->group('api', ['filter' => 'tokens'], function($routes) { // }); $routes->get('users', 'UserController::list', ['filter' => 'tokens:users-read']); When the filter runs, it checks the Authorization header for a Bearer value that has the raw token. It then hashes the raw token and looks it up in the database. Once found, it can determine the correct user, which will then be available through an auth()->user() call. Note Currently only a single scope can be used on a route filter. If multiple scopes are passed in, only the first one is checked.","title":"Protecting Routes"},{"location":"guides/mobile_apps/","text":"Mobile Authentication with Access Tokens Access Tokens can be used to authenticate mobile applications that are consuming your API. This is similar to how you would work with third-party users of your API, but with small differences in how you would issue the tokens. Issuing the Tokens Typically, a mobile application would issue a request from their login screen, passing in the credentials to authenticate with. Once authenticated you would return the raw token within the response and that would be saved on the device to use in following API calls. Start by creating a route that would handle the request from the login screen on the mobile device. The device name can be any arbitrary string, but is typically used to identify the device the request is being made from, like \"Johns iPhone 13\". // Routes.php $routes->post('auth/token', '\\App\\Controllers\\Auth\\LoginController::mobileLogin'); // LoginController.php namespace App\\Controllers\\Auth; use App\\Controllers\\BaseController; class LoginController extends BaseController { public function mobileLogin() { // Validate credentials $rules = setting('Validation.login') ?? [ 'email' => [ 'label' => 'Auth.email', 'rules' => config('AuthSession')->emailValidationRules, ], 'password' => [ 'label' => 'Auth.password', 'rules' => 'required', ], ]; if (! $this->validate($rules)) { return $this->response ->setJSON(['errors' => $this->validator->getErrors()]) ->setStatusCode(422); } // Attempt to login $result = auth()->attempt($this->request->getPost(setting('Auth.validFields'))); if (! $result->isOK()) { return $this->response ->setJSON(['error' => $result->reason()]) ->setStatusCode(401); } // Generate token and return to client $token = auth()->user()->generateAccessToken(service('request')->getVar('device_name')); return $this->response ->setJSON(['token' => $token->raw_token]); } } When making all future requests to the API, the mobile client should return the raw token in the Authorization header as a Bearer token. Note By default, $authenticatorHeader['tokens'] is set to Authorization . You can change the header name by setting the $authenticatorHeader['tokens'] value in the Auth.php config file. e.g. if $authenticatorHeader['tokens'] is set to PersonalAccessCodes then the mobile client should return the raw token in the PersonalAccessCodes header as a Bearer token.","title":"Mobile Authentication with Access Tokens"},{"location":"guides/mobile_apps/#mobile-authentication-with-access-tokens","text":"Access Tokens can be used to authenticate mobile applications that are consuming your API. This is similar to how you would work with third-party users of your API, but with small differences in how you would issue the tokens.","title":"Mobile Authentication with Access Tokens"},{"location":"guides/mobile_apps/#issuing-the-tokens","text":"Typically, a mobile application would issue a request from their login screen, passing in the credentials to authenticate with. Once authenticated you would return the raw token within the response and that would be saved on the device to use in following API calls. Start by creating a route that would handle the request from the login screen on the mobile device. The device name can be any arbitrary string, but is typically used to identify the device the request is being made from, like \"Johns iPhone 13\". // Routes.php $routes->post('auth/token', '\\App\\Controllers\\Auth\\LoginController::mobileLogin'); // LoginController.php namespace App\\Controllers\\Auth; use App\\Controllers\\BaseController; class LoginController extends BaseController { public function mobileLogin() { // Validate credentials $rules = setting('Validation.login') ?? [ 'email' => [ 'label' => 'Auth.email', 'rules' => config('AuthSession')->emailValidationRules, ], 'password' => [ 'label' => 'Auth.password', 'rules' => 'required', ], ]; if (! $this->validate($rules)) { return $this->response ->setJSON(['errors' => $this->validator->getErrors()]) ->setStatusCode(422); } // Attempt to login $result = auth()->attempt($this->request->getPost(setting('Auth.validFields'))); if (! $result->isOK()) { return $this->response ->setJSON(['error' => $result->reason()]) ->setStatusCode(401); } // Generate token and return to client $token = auth()->user()->generateAccessToken(service('request')->getVar('device_name')); return $this->response ->setJSON(['token' => $token->raw_token]); } } When making all future requests to the API, the mobile client should return the raw token in the Authorization header as a Bearer token. Note By default, $authenticatorHeader['tokens'] is set to Authorization . You can change the header name by setting the $authenticatorHeader['tokens'] value in the Auth.php config file. e.g. if $authenticatorHeader['tokens'] is set to PersonalAccessCodes then the mobile client should return the raw token in the PersonalAccessCodes header as a Bearer token.","title":"Issuing the Tokens"}]}